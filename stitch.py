# stitch the two meshes generated by output.py
import numpy as np
import cv2
import copy
from warp import getinnerpts
from point_correspondence import dpBoundarymatch


def initialcontours(front_path, back_path):

    front = cv2.imread(front_path, -1)
    inner_pts1 = getinnerpts(front_path)
    inner_pts1 = inner_pts1.tolist()

    if len(front.shape) == 3:
        front = cv2.cvtColor(front, cv2.COLOR_BGR2GRAY)

    contours1, hierarchy = cv2.findContours(front, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    contours1 = np.array(contours1)

    back = cv2.imread(back_path, -1)
    inner_pts2 = getinnerpts(back_path)
    inner_pts2 = inner_pts2.tolist()

    if len(back.shape) == 3:
        back = cv2.cvtColor(back, cv2.COLOR_BGR2GRAY)

    contours2, hierarchy = cv2.findContours(back, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    contours2 = np.array(contours2)

    return contours1, contours2, inner_pts1, inner_pts2


# align inner_pts1 to inner_pts2
def mesh_align(inner_pts1, inner_pts2):

    len1 = len(inner_pts1)

    cover = 0
    for i in range(0, len1):
        if inner_pts1[i] in inner_pts2:
            cover += 1

    cover_max = cover/len1

    temp1 = copy.deepcopy(inner_pts1)
    for i in range(0, len1):
        temp1[i][0] += 1

    cover = 0
    for i in range(0, len1):
        if temp1[i] in inner_pts2:
            cover += 1

    plus = cover/len1

    temp2 = copy.deepcopy(inner_pts1)
    for i in range(0, len1):
        temp2[i][0] -= 1

    cover = 0
    for i in range(0, len1):
        if temp2[i] in inner_pts2:
            cover += 1

    minus = cover/len1

    print(plus, cover_max, minus)

    if plus >= cover_max >= minus:
        cover_max = plus
        bias = 1
        while True:
            cover = 0
            for i in range(0, len1):
                temp1[i][0] += 1

            for i in range(0, len1):
                if temp1[i] in inner_pts2:
                    cover += 1

            print('%d: %f' % (bias, cover/len1))

            if cover_max > cover / len1:
                break

            else:
                cover_max = cover/len1
                bias += 1

        return bias

    elif minus >= cover_max >= plus:

        cover_max = minus
        bias = 1
        while True:
            cover = 0
            for i in range(0, len1):
                temp2[i][0] -= 1

            for i in range(0, len1):
                if temp2[i] in inner_pts2:
                    cover += 1

            print('-%d: %f' % (bias, cover / len1))

            if cover_max > cover / len1:
                break

            else:
                cover_max = cover / len1
                bias += 1

        return -bias

    else:
        return 0


# apply bias on contours1, mesh_idx of back should greater than it of front
def mesh_stitch(contours1, contours2, mesh_idx1, mesh_idx2, vert_dict, outfile, bias=0):

    len = contours1.shape[1]

    with open(outfile, 'a+') as output:

        for i in range(0, len):
            contours1[0, i, 0, 0] += bias

        phi = dpBoundarymatch(contours1, contours2, 6)

        for i in range(0, len):

            if i == len - 1:
                continue

            mesh_list = [contours1[0, i, 0, :], contours1[0, i + 1, 0, :]]

            if phi[i] == phi[i+1]:
                mesh_list.append(contours2[0, phi[i], 0, :])

            else:
                mesh_list.append(contours2[0, phi[i+1], 0, :])
                mesh_list.append(contours2[0, phi[i], 0, :])

            mesh_list = np.array(mesh_list)

            if mesh_list.shape[0] == 3:
                x1, y1 = mesh_list[0, :]
                a = vert_dict[(x1, y1, mesh_idx1)]
                x2, y2 = mesh_list[1, :]
                b = vert_dict[(x2, y2, mesh_idx1)]
                x3, y3 = mesh_list[2, :]
                c = vert_dict[(x3, y3, mesh_idx2)]

                if mesh_idx1 > mesh_idx2:
                    mesh = 'f %d %d %d\n' % (c, b, a)
                elif mesh_idx1 < mesh_idx2:
                    mesh = 'f %d %d %d\n' % (a, b, c)

                output.write(mesh)

            if mesh_list.shape[0] == 4:
                x1, y1 = mesh_list[0, :]
                a = vert_dict[(x1, y1, mesh_idx1)]
                x2, y2 = mesh_list[1, :]
                b = vert_dict[(x2, y2, mesh_idx1)]
                x3, y3 = mesh_list[2, :]
                c = vert_dict[(x3, y3, mesh_idx2)]
                x4, y4 = mesh_list[3, :]
                d = vert_dict[(x4, y4, mesh_idx2)]

                if mesh_idx1 > mesh_idx2:
                    mesh = 'f %d %d %d %d\n' % (d, c, b, a)
                elif mesh_idx1 < mesh_idx2:
                    mesh = 'f %d %d %d %d\n' % (a, b, c, d)

                output.write(mesh)

            print('%d/%d stitch mesh' % (i, len))
